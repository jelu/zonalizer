#!/usr/bin/env perl

use common::sense;

use EV;
use AnyEvent;
use Log::Log4perl;
use Lim::Plugin::Zonalizer qw(:status);
use DB_File;
use HTTP::Status;
use AnyEvent::HTTP;
use Lim::RPC::TLS;

use Data::Dumper;

STDOUT->autoflush(1);

Log::Log4perl->init( \q(
log4perl.logger                   = DEBUG, Screen
log4perl.appender.Screen          = Log::Log4perl::Appender::Screen
log4perl.appender.Screen.stderr   = 0
log4perl.appender.Screen.layout   = Log::Log4perl::Layout::PatternLayout
log4perl.appender.Screen.layout.ConversionPattern = %d %F [%L] %p: %m%n
) );
my $logger = Log::Log4perl->get_logger;

Lim::LoadConfig($ARGV[0]);
Lim::UpdateConfig;

Lim::Config->{zonalizer}->{iana_interval} ||= 86400;
Lim::Config->{zonalizer}->{limit} ||= 10;

my ($state, %state, %tld, $ongoing, $exit);
$state = tie %state, 'DB_File', $ARGV[1];

#$state{after} = '1464085879:l2ReQ74RSnCtYNrI51-czQ';

my $cv = AnyEvent->condvar;

my ( $update_w, $read_w );

my @watchers = (
    AnyEvent->signal(signal => "HUP", cb => sub {
    }),
    AnyEvent->signal(signal => "PIPE", cb => sub {
    }),
    AnyEvent->signal(signal => "INT", cb => sub {
        if ( $ongoing ) {
            $exit = 1;
        }
        else {
            $update_w = $read_w = undef;
            $cv->send;
        }
    }),
    AnyEvent->signal(signal => "QUIT", cb => sub {
        if ( $ongoing ) {
            $exit = 1;
        }
        else {
            $update_w = $read_w = undef;
            $cv->send;
        }
    }),
    AnyEvent->signal(signal => "TERM", cb => sub {
        if ( $ongoing ) {
            $exit = 1;
        }
        else {
            $update_w = $read_w = undef;
            $cv->send;
        }
    })
);

$update_w = AnyEvent->timer( after => 0, interval => Lim::Config->{zonalizer}->{iana_interval}, cb => sub {
    Lim::DEBUG and $logger->debug('Getting IANA');

    my $req; $req = http_get Lim::Config->{zonalizer}->{iana_url}, sub {
        my ($body, $hdr) = @_;

        unless ($hdr->{Status} == 200) {
            Lim::ERR and $logger->error('Failed to get ', Lim::Config->{zonalizer}->{iana_url}, ' [', $hdr->{Status}, ( defined $hdr->{'content-type'} ? ' / '.$hdr->{'content-type'} : () ), ']');
            undef $req;
            return;
        }

        my ( $tlds, $type, $company, $last ) = ( 0, 0, 0 );

        foreach (split(/[\r\n]+/omg, $body)) {
            if ($type and /td>([^<]+)/o) {
                $tld{$last}->{type} = $1;
                $tld{$last}->{type} =~ s/[\s,]/_/go;
                $type = 0;
                $company = 1;
                next;
            }
            if ($company and /td>([^<]+)/o) {
                $tld{$last}->{company} = $1;
                $tld{$last}->{company} =~ s/,/\./go;
                $tld{$last}->{company} =~ s/"//go;
                $tld{$last}->{company} =~ s/\&[a-z];//go;
                $tld{$last}->{company} =~ s/ /\\ /go;
                $company = 0;
                $tlds++;
                next;
            }
            if (/href="\/domains\/root\/db\/([^\.]+\.)html">\.([^<]+)/o) {
                $tld{$1} = {
                    idn => $1,
                    tld => $2
                };
                $last = $1;
                $type = 1;
                next;
            }
        }

        Lim::DEBUG and $logger->debug($tlds, ' TLDs found');

        undef $req;
    };
});

$read_w = AnyEvent->timer( after => 2, cb => \&fetch_analysis );

sub fetch_analysis {
    unless ( scalar %tld ) {
        $read_w = AnyEvent->timer( after => 2, cb => \&fetch_analysis );
        return;
    }

    Lim::DEBUG and $logger->debug('Fetching results', ($state{after} ? ' after '.$state{after} : ''));

    Lim::Plugin::Zonalizer->Client->ReadAnalysis({
        version => 1,
        limit => Lim::Config->{zonalizer}->{limit},
        sort => 'created',
        direction => 'ascending',
        ( $state{after} ? ( after => $state{after} ) : ())
    },
    sub {
        my ( $c, $r ) = @_;

        unless ( $c->Successful ) {
            Lim::ERR and $logger->error('Zonalizer error while reading: ', $c->Error->toString);
            $read_w = AnyEvent->timer( after => 10, cb => \&fetch_analysis );
            return;
        }

        unless ( exists $r->{analysis} ) {
            Lim::ERR and $logger->error('Bad data!');
            $read_w = AnyEvent->timer( after => 10, cb => \&fetch_analysis );
            return;
        }

        unless ( ref($r->{paging}) eq 'HASH' and ref($r->{paging}->{cursors}) eq 'HASH' ) {
            Lim::DEBUG and $logger->debug('No cursors or data');
            $read_w = AnyEvent->timer( after => 60, cb => \&fetch_analysis );
            return;
        }

        my $unfinished = 0;
        foreach my $analyze ( ref($r->{analysis}) eq 'ARRAY' ? @{$r->{analysis}} : $r->{analysis} ) {
            unless ( exists $tld{$analyze->{fqdn}} ) {
                next;
            }
            if ( $analyze->{status} eq STATUS_RESERVED
                or $analyze->{status} eq STATUS_QUEUED
                or $analyze->{status} eq STATUS_ANALYZING )
            {
                $unfinished = 1;
                last;
            }
        }

        if ( $unfinished ) {
            Lim::DEBUG and $logger->debug('Not everything done, retrying...');
            $read_w = AnyEvent->timer( after => 30, cb => \&fetch_analysis );
            return;
        }

        $ongoing = 1;

        my @influx;
        foreach my $analyze ( ref($r->{analysis}) eq 'ARRAY' ? @{$r->{analysis}} : $r->{analysis} ) {
            unless ( exists $tld{$analyze->{fqdn}} ) {
                next;
            }

            my $tags = 'fqdn='.$analyze->{fqdn}.',type='.$tld{$analyze->{fqdn}}->{type}.',company='.$tld{$analyze->{fqdn}}->{company};
            my $time = $analyze->{created}.'000000000';
            push(@influx,
                'summary,'.$tags.' critical='.$analyze->{summary}->{critical}.',error='.$analyze->{summary}->{error}.',warning='.$analyze->{summary}->{warning}.',notice='.$analyze->{summary}->{notice}.' '.$time,
            );
        }

        Lim::DEBUG and $logger->debug(scalar @influx, ' new metrics from ', scalar @{$r->{analysis}}, ' analysis');

        my $req; $req = http_post Lim::Config->{zonalizer}->{influx_url}, join("\n", @influx), sub {
            my ($body, $hdr) = @_;

            unless ($hdr->{Status} >= 200 and $hdr->{Status} < 300) {
                Lim::ERR and $logger->error('Failed to store metrics [', $hdr->{Status}, ']');
            }

            $state{after} = $r->{paging}->{cursors}->{after};
            $state->sync;
            $ongoing = 0;
            if ( $exit ) {
                $cv->send;
                return;
            }
            $read_w = AnyEvent->timer( after => 1, cb => \&fetch_analysis );

            undef $req;
            return;
        };
    },
    {
        uri => Lim::Config->{zonalizer}->{uri}
    });
}

sub fatal {
    $logger->fatal(@_);
    $update_w = $read_w = undef;
    $cv->send;
}

$cv->recv;
Lim::INFO and $logger->info('Exit');
